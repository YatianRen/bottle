/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: dwalsh (https://sketchfab.com/dwalsh)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/energy-drink-game-ready-model-83676feb8b0a4589952cf3676299311b
Title: Energy Drink Game Ready Model
*/

import React, { useEffect, useMemo, useRef, useState } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import { Color, Vector2 } from "three";
import { animate } from "framer-motion";
import { easeQuadOut } from "d3-ease";

import { noise } from "./Noise";
import { useStore } from "./store";
import { wines } from "./data";

// Updated to use JD bottle model
import model from "./assets/models/jd_bottle.glb?url";

const Model = (props) => {
  const { nodes, materials } = useGLTF(model);

  const {
    viewport: { width, height },
  } = useThree();

  const modelRef = useRef();
  const groupRef = useRef(); // Separate ref for the group positioning
  const [current, setCurrent] = useState(0);

  const play = useStore((s) => s.play);
  const setPlay = useStore((s) => s.setPlay);
  const setCurrentWine = useStore((s) => s.setCurrentWine);

  // Log available materials to help identify the correct one
  useEffect(() => {
    console.log("Available materials:", Object.keys(materials));
    console.log("Available nodes:", Object.keys(nodes));
  }, [materials, nodes]);

  const uniforms = useMemo(
    () => ({
      u_time: { value: 0 },
      u_color1: { value: new Color(wines[0].color) },
      u_color2: { value: new Color(wines[1].color) },
      u_progress: { value: 0.5 },
      u_width: { value: 0.8 },
      u_scaleX: { value: 50 },
      u_scaleY: { value: 50 },
      u_textureSize: {
        value: new Vector2(1024, 1024), // Default size, will update when material is found
      },
    }),
    [wines]
  );

  const handleClick = () => {
    let len = wines.length;
    let nextIndex = (current + 1) % len;
    let nextTexture = new Color(wines[nextIndex].color);
    uniforms.u_color2.value = nextTexture;

    if (play) {
      animate(0.5, 1, {
        onUpdate(v) {
          setPlay(false);
          uniforms.u_progress.value = v;
        },
        onComplete() {
          setCurrent(nextIndex);
          setCurrentWine(wines[nextIndex]);

          uniforms.u_color1.value = nextTexture;
          uniforms.u_progress.value = 0.5;
          setPlay(true);
        },

        duration: 1.2,
        ease: easeQuadOut,
      });
    }
  };

  useFrame(({ clock }) => {
    const time = clock.getElapsedTime();
    uniforms.u_time.value = time;

    // üéØ ANIMATION CENTER CONTROL - This controls the floating animation
    // The animation is applied to the modelRef, which is the inner group
    
    // ‚¨ÜÔ∏è VERTICAL FLOATING (Y-axis) - This should work now!
    // Change the numbers to adjust:
    // - First number (0.8): speed of floating
    // - Second number (0.15): how high/low it floats
    if (modelRef.current) {
      modelRef.current.position.y = Math.sin(time * 0.8) * 0.15;
      
      // üîÑ GENTLE ROTATION (Y-axis)
      // - First number (0.3): speed of rotation
      // - Second number (0.05): how much it rotates
      modelRef.current.rotation.y = Math.sin(time * 0.3) * 0.05;
      
      // üåä OPTIONAL: Add side-to-side floating (X-axis)
      // Uncomment this line to add horizontal floating:
      // modelRef.current.position.x = Math.cos(time * 0.5) * 0.03;
    }
  });

  useEffect(() => {
    // Initialize current wine in store
    setCurrentWine(wines[0]);
  }, [setCurrentWine]);

  useEffect(() => {
    // Find and apply shader to all materials
    Object.values(materials).forEach((material) => {
      if (material) {
        // üé® TEXTURE BRIGHTNESS CONTROL - Adjust these values:
        material.metalness = 0.2;  // Lower = less metallic (0-1)
        material.roughness = 0.6;  // Lower = more shiny (0-1)
        
        // üí° BRIGHTNESS BOOST - Uncomment to make brighter:
        // material.emissive = new Color(0x111111); // Adds glow
        
        material.onBeforeCompile = (shader) => {
          shader.uniforms = Object.assign(shader.uniforms, uniforms);
          shader.vertexShader = shader.vertexShader.replace(
            `#include <common>`,
            `
              #include <common>
              varying vec2 vUv;
            `
          );

          shader.vertexShader = shader.vertexShader.replace(
            "#include <begin_vertex>",
            `
              #include <begin_vertex>
              vUv = uv;
            `
          );

          // Fragment Shader
          shader.fragmentShader = shader.fragmentShader.replace(
            `#include <common>`,
            `
              #include <common>

              uniform float u_time;
              uniform vec3 u_color1;
              uniform vec3 u_color2;
              uniform float u_progress;
              uniform float u_width;
              uniform float u_scaleX;
              uniform float u_scaleY;
              uniform vec2 u_textureSize;

              varying vec2 vUv;
              
              ${noise}

              float parabola( float x, float k ) {
                return pow( 4. * x * ( 1. - x ), k );
              }
          `
          );

          shader.fragmentShader = shader.fragmentShader.replace(
            `#include <color_fragment>`,
            `
              #include <color_fragment>

                float aspect = u_textureSize.x/u_textureSize.y;

                float dt = parabola(u_progress,1.);
                float border = 1.;

                float noise = 0.5*(cnoise(vec4(vUv.x*u_scaleX + 0.5*u_time/4., vUv.y*u_scaleY,0.5*u_time/4.,0.)) + 1.);

                float w = u_width*dt;

                float maskValue = smoothstep(1. - w,1.,vUv.y + mix(-w/2., 1. - w/2., u_progress));

                maskValue += maskValue * noise * 0.3;

                float mask = smoothstep(border,border+0.01,maskValue);

                // üç∑ Enhanced wine colors with brightness boost
                vec3 wine1 = u_color1 * 2.0;  // Increase this number for brighter colors
                vec3 wine2 = u_color2 * 2.0;  // Increase this number for brighter colors

                diffuseColor.rgb += mix(wine1, wine2, mask);
                
                // üí° OVERALL BRIGHTNESS BOOST - Uncomment to make everything brighter:
                // diffuseColor.rgb *= 1.5;
            `
          );
        };
      }
    });
  }, [uniforms, materials]);

  return (
    <>
      {/* Plane helper for click event */}
      <mesh visible={false} onClick={() => handleClick()}>
        <planeGeometry args={[width, height]} />
      </mesh>

      {/* üìç MAIN POSITIONING CONTROL - This controls where the bottle appears on screen */}
      <group
        ref={groupRef}
        // üîÑ ROTATION: [x-axis, y-axis, z-axis] in radians
        // Adjust these to change the bottle's orientation:
        rotation={[0, 1.2, 0]}
        
        // üìç POSITION: [x, y, z] - This controls the bottle's location
        // x: left(-) / right(+) - try values like -2, 0, 2, 4
        // y: down(-) / up(+) - try values like -2, 0, 2, 4  
        // z: back(-) / forward(+) - try values like 3, 5, 7
        position={[2, 1, 5]}
        
        // üìè SCALE: [x, y, z] - Make the bottle bigger/smaller
        // Try values like [1, 1, 1] for normal size, [2, 2, 2] for double size
        scale={[1.5, 1.5, 1.5]}
        
        {...props}
        dispose={null}
      >
        {/* üé≠ ANIMATION GROUP - This is what actually moves during animation */}
        <group ref={modelRef}>
          {/* Render all meshes from the JD bottle model */}
          {Object.entries(nodes).map(([name, node]) => {
            if (node.geometry) {
              const materialName = node.material?.name || name;
              const material = materials[materialName] || materials[Object.keys(materials)[0]];
              
              return (
                <mesh
                  key={name}
                  geometry={node.geometry}
                  material={material}
                  rotation={node.rotation}
                  position={node.position}
                  scale={node.scale}
                />
              );
            }
            return null;
          })}
        </group>
      </group>
    </>
  );
};

useGLTF.preload(model);

export default Model;