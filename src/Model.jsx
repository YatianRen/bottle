/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: dwalsh (https://sketchfab.com/dwalsh)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/energy-drink-game-ready-model-83676feb8b0a4589952cf3676299311b
Title: Energy Drink Game Ready Model
*/

import React, { useEffect, useMemo, useRef, useState } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import { Color, Vector2 } from "three";
import { animate } from "framer-motion";
import { easeQuadOut } from "d3-ease";

import { noise } from "./Noise";
import { useStore } from "./store";
import { wines } from "./data";

// Updated to use JD bottle model
import model from "./assets/models/jd_bottle.glb?url";

const Model = (props) => {
  const { nodes, materials } = useGLTF(model);

  const {
    viewport: { width, height },
  } = useThree();

  const modelRef = useRef();
  const [current, setCurrent] = useState(0);

  const play = useStore((s) => s.play);
  const setPlay = useStore((s) => s.setPlay);
  const setCurrentWine = useStore((s) => s.setCurrentWine);

  // Log available materials to help identify the correct one
  useEffect(() => {
    console.log("Available materials:", Object.keys(materials));
    console.log("Available nodes:", Object.keys(nodes));
  }, [materials, nodes]);

  const uniforms = useMemo(
    () => ({
      u_time: { value: 0 },
      u_color1: { value: new Color(wines[0].color) },
      u_color2: { value: new Color(wines[1].color) },
      u_progress: { value: 0.5 },
      u_width: { value: 0.8 },
      u_scaleX: { value: 50 },
      u_scaleY: { value: 50 },
      u_textureSize: {
        value: new Vector2(1024, 1024), // Default size, will update when material is found
      },
    }),
    [wines]
  );

  const handleClick = () => {
    let len = wines.length;
    let nextIndex = (current + 1) % len;
    let nextTexture = new Color(wines[nextIndex].color);
    uniforms.u_color2.value = nextTexture;

    if (play) {
      animate(0.5, 1, {
        onUpdate(v) {
          setPlay(false);
          uniforms.u_progress.value = v;
        },
        onComplete() {
          setCurrent(nextIndex);
          setCurrentWine(wines[nextIndex]);

          uniforms.u_color1.value = nextTexture;
          uniforms.u_progress.value = 0.5;
          setPlay(true);
        },

        duration: 1.2,
        ease: easeQuadOut,
      });
    }
  };

  useFrame(({ clock }) => {
    const time = clock.getElapsedTime();
    uniforms.u_time.value = time;

    // ANIMATION CENTER CONTROL - This is where you control the floating animation
    // You can adjust these values to change the animation behavior:
    
    // Vertical floating (Y-axis) - change amplitude (0.08) and speed (0.8)
    modelRef.current.position.y = Math.sin(time * 0.8) * 0.08;
    
    // Gentle rotation (Y-axis) - change amplitude (0.05) and speed (0.3)
    modelRef.current.rotation.y = Math.sin(time * 0.3) * 0.05;
    
    // Optional: Add X-axis floating
    // modelRef.current.position.x = Math.cos(time * 0.5) * 0.03;
    
    // Optional: Add Z-axis rotation
    // modelRef.current.rotation.z = Math.sin(time * 0.4) * 0.02;
  });

  useEffect(() => {
    // Initialize current wine in store
    setCurrentWine(wines[0]);
  }, [setCurrentWine]);

  useEffect(() => {
    // Find the main material for the bottle
    // Common material names for bottles: "Material", "Bottle", "Glass", "Body", etc.
    const materialNames = Object.keys(materials);
    let targetMaterial = null;
    
    // Try to find the main bottle material
    const possibleNames = ['Material', 'Bottle', 'Glass', 'Body', 'Main'];
    for (const name of possibleNames) {
      if (materials[name]) {
        targetMaterial = materials[name];
        break;
      }
    }
    
    // If no specific material found, use the first available material
    if (!targetMaterial && materialNames.length > 0) {
      targetMaterial = materials[materialNames[0]];
      console.log(`Using material: ${materialNames[0]}`);
    }

    if (targetMaterial) {
      // Update texture size if material has a map
      if (targetMaterial.map) {
        uniforms.u_textureSize.value = new Vector2(
          targetMaterial.map.source.data.width,
          targetMaterial.map.source.data.height
        );
      }

      targetMaterial.metalness = 0.1;
      targetMaterial.roughness = 0.8;
      targetMaterial.onBeforeCompile = (shader) => {
        shader.uniforms = Object.assign(shader.uniforms, uniforms);
        shader.vertexShader = shader.vertexShader.replace(
          `#include <common>`,
          `
            #include <common>
            varying vec2 vUv;
          `
        );

        shader.vertexShader = shader.vertexShader.replace(
          "#include <begin_vertex>",
          `
            #include <begin_vertex>
            vUv = uv;
          `
        );

        // Fragment Shader
        shader.fragmentShader = shader.fragmentShader.replace(
          `#include <common>`,
          `
            #include <common>

            uniform float u_time;
            uniform vec3 u_color1;
            uniform vec3 u_color2;
            uniform float u_progress;
            uniform float u_width;
            uniform float u_scaleX;
            uniform float u_scaleY;
            uniform vec2 u_textureSize;

            varying vec2 vUv;
            
            ${noise}

            float parabola( float x, float k ) {
              return pow( 4. * x * ( 1. - x ), k );
            }
        `
        );

        shader.fragmentShader = shader.fragmentShader.replace(
          `#include <color_fragment>`,
          `
            #include <color_fragment>

              float aspect = u_textureSize.x/u_textureSize.y;

              float dt = parabola(u_progress,1.);
              float border = 1.;

              float noise = 0.5*(cnoise(vec4(vUv.x*u_scaleX + 0.5*u_time/4., vUv.y*u_scaleY,0.5*u_time/4.,0.)) + 1.);

              float w = u_width*dt;

              float maskValue = smoothstep(1. - w,1.,vUv.y + mix(-w/2., 1. - w/2., u_progress));

              maskValue += maskValue * noise * 0.3;

              float mask = smoothstep(border,border+0.01,maskValue);

              // Enhanced wine colors with more depth
              vec3 wine1 = u_color1 * 1.2;
              vec3 wine2 = u_color2 * 1.2;

              diffuseColor.rgb += mix(wine1, wine2, mask);
          `
        );
      };
    }
  }, [uniforms, materials]);

  return (
    <>
      {/* Plane helper for click event */}
      <mesh visible={false} onClick={() => handleClick()}>
        <planeGeometry args={[width, height]} />
      </mesh>

      {/* MODEL POSITIONING CONTROL - This is where you control the bottle's position and rotation */}
      <group
        ref={modelRef}
        // ROTATION: [x-axis, y-axis, z-axis] in radians
        // Current: slightly rotated to show the bottle nicely
        rotation={[-90, 1.2, 0]}
        
        // POSITION: [x, y, z] - move the bottle in 3D space
        // x: left(-) / right(+)
        // y: down(-) / up(+) 
        // z: back(-) / forward(+)
        position={[2, 0, 5]}
        
        // SCALE: [x, y, z] - make the bottle bigger/smaller
        scale={[1.3, 1.3, 1.3]}
        
        {...props}
        dispose={null}
      >
        {/* Render all meshes from the JD bottle model */}
        {Object.entries(nodes).map(([name, node]) => {
          if (node.geometry && node.material) {
            return (
              <mesh
                key={name}
                geometry={node.geometry}
                material={materials[node.material.name] || node.material}
                rotation={node.rotation}
                position={node.position}
                scale={node.scale}
              />
            );
          }
          return null;
        })}
      </group>
    </>
  );
};

useGLTF.preload(model);

export default Model;